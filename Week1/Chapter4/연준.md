**자바스크립트 엔진이 자바스크립트 코드를 계산(평가)하려면 먼저 기호(리터럴과 연산자)의 의미를 알고 있어야 하며, 표현식의 의미도 해석(파싱)할 수 있어야 한다.**

평가, 리터럴과 연산자, 표현식, 파싱

### 평가 (Evaluation)
평가는 코드 실행 과정에서 특정 표현식이나 문장이 실제 값으로 대체되는 것을 의미.
자바스크립트 엔진은 코드를 실행하면서 표현식을 평가하고, 변수에 할당되는 등의 동작을 수행

### 리터럴(Literal)
리터럴은 코드에 직접 나타나는 데이터 값 자체를 의미.

### 연산자(Operator)
연산자는 값을 연산하거나 조작하는 데 사용되는 기호 또는 키워드.

### 표현식(Expression)
표현식은 값, 변수, 연산자의 조합으로 이루어진 코드 조각을 의미
표현식은 결과적으로 하나의 값으로 평가된다.

### 파싱(Parsing)
파싱은 소스 코드를 분석하고 문법 규칙에 따라 ***추상 구문 트리(Abstract Syntax Tree, AST)***를 생성하는 과정을 말한다
자바스크립트 엔진은 코드를 읽어들이고 이를 토큰으로 분해한 다음, 이를 기반으로 추상 구문 트리를 생성하여 실행

### 파싱의 단계
#### 토큰화 (Lexical Analysis)
소스 코드를 토큰(Token)으로 분해하는 단계
토큰은 언어의 기본 구성 단위로, 식별자, 예약어, 연산자, 숫자, 문자열 등이 될 수 있다.
토큰화는 일련의 문자열을 토큰으로 변환하는 작업을 수행한다

#### 구문 분석 (Syntax Analysis)
토큰화된 토큰들을 이용하여 문법 규칙에 따라 문장의 구조를 해석하는 단계
문법 규칙은 언어의 문법에 따라 정의되며, 이를 기반으로 추상 구문 트리(AST)를 생성
일반적으로 구문 분석은 컨텍스트-자유 문법(Context-Free Grammar, CFG)을 기반으로 한다,

#### AST 생성 (Abstract Syntax Tree)
구문 분석의 결과로 추상 구문 트리가 생성된다.
AST는 소스 코드의 추상적인 구조를 나타내며, 트리 구조로 표현된다.
각 노드는 토큰 또는 표현식을 나타내고, 노드 간의 관계는 문법 규칙에 따라 정의된다.

```
let sum = 2 + 3; //소스코드
[let] [sum] [=] [2] [+] [3] [;] //토큰화
AssignmentExpression(할당표현식) //구문 분석 및 AST
├── Identifier (sum) (식별자)
└── BinaryExpression  (이항 표현식)
    ├── Literal (2)
    ├── Operator (+)
    └── Literal (3)
```

자바스크립트는 개발자의 직접적인 메모리 제어를 허용하지 않음
=> 치명적인 오류를 발생시킬 가능성이 높은 일이기 때문
어떤 치명적인 오류?
메모리 오버플로우, 메모리 누수와 같은 치명적인 버그를 방지
가비지 컬렉션을 이용한 메모리 관리 => 누수가 일어나지 않도록.
가비지 컬렉션은 더 이상 필요하지 않은 객체나 변수를 식별하고 자동으로 메모리에서 제거

```
function createClosure() {
  const data = 'Some data';
  return function() {
    console.log(data);
  };
}

const leakyClosure = createClosure();
```
이 코드에서 leakyClosure는 외부 함수의 data 변수에 대한 참조를 계속 유지하고 있어 해당 함수 스코프의 데이터에 접근 가능. 이로 인해 해당 데이터는 가비지 컬렉션되지 않아 메모리 누수가 발생

### 변수(variable)
하나의 값을 지정하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름.
=> 프로그래밍 언어에서 값을 지정하고 참조하는 메커니즘, 값의 위치를 가리키는 상징적인 이름.

변수이름 = 변수값
=> 할당
변수이름으로 지정된 값을 읽어 들이는것을 참조.

### 상수와 변수
#### 변수 (Variable)
**선언**
(var, let, const)
**할당 (Assignment)** 
값을 변수에 할당할 수 있다.
**재할당 가능 (Reassignment)**
var와 let으로 선언된 변수는 값을 여러 번 할당하고 변경할 수 있다.
**스코프 (Scope)**
var는 함수 스코프를 가지고 있어 함수 내에서만 유효하고 함수 외부에서는 접근할 수 없다.
let은 블록 스코프를 가지고 있어 블록 내에서만 유효하며 블록 외부에서는 접근할 수 없다.

#### 상수 (Const)
**선언**
const 키워드를 사용하여 상수를 선언합니다.
**재할당 불가 (Reassignment)**
const로 선언된 상수는 선언 후에 값을 변경할 수 없다.
**스코프 (Scope**
const도 블록 스코프를 가지고 있어 블록 내에서만 유효하다.

const는 상수의 재할당을 방지하지만, 객체 또는 배열과 같은 참조형 데이터의 내부 속성은 수정할 수 있다. 하지만 객체나 배열 자체를 다른 객체나 배열로 재할당하는 것은 불가능

#### 상수 구분
상수를 나타내는 변수명에는 보통 대문자만을 사용하며, 단어 사이를 언더스코어(_)로 연결. 이를 *"상수 케이스"* 또는 *"대문자 스네이크 케이스"*라고 부름.

### 식별자
변수 함수 클래스 등의 이름은 모두 식별자.
특수문자를 제외한 문자, 숫자, 언더바, 달러기호를 포함할 수 있다.
but숫자로 시작되는것은 허용하지 않는다.
예약어는 사용할 수 없다.
=> 메모리상에 존재하는 어떤 값을 식별할 수 있는 이름

### 호이스팅
자바스크립트 엔진은 소스코드를 한줄씩 순차적으로 실행하기 앞서 먼저 소스코드 평가 과정을 거친다, 이때 변수 선언을 포함한 모든 선언문을 소스코드에서 찾아내 먼저 실행한다. 이 이 후 선언문을 제외하고 소스코드를 한줄씩 순차적으로 실행한다.

재할당은 변수에 저장된 값을 다른 값으로 변경한다. 값을 재할당 할 수 없어서 변수에 저장된 값을 변경할 수 없다면 변수가 아니라 상수라 한다.